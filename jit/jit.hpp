#pragma once
#include "expressions.hpp"
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif
#include "llvm/ExecutionEngine/Orc/ThreadSafeModule.h"
#include "llvm/Support/Error.h"
#include "llvm/Target/TargetMachine.h"
#include <llvm/ADT/StringRef.h>
#include <llvm/ExecutionEngine/JITSymbol.h>
#include <llvm/ExecutionEngine/Orc/CompileUtils.h>
#include <llvm/ExecutionEngine/Orc/Core.h>
#include <llvm/ExecutionEngine/Orc/ExecutionUtils.h>
#include <llvm/ExecutionEngine/Orc/ExecutorProcessControl.h>
#include <llvm/ExecutionEngine/Orc/IRCompileLayer.h>
#include <llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h>
#include <llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h>
#include <llvm/ExecutionEngine/Orc/Shared/ExecutorSymbolDef.h>
#include <llvm/ExecutionEngine/SectionMemoryManager.h>
#include <llvm/IR/DataLayout.h>
#include <llvm/IR/LLVMContext.h>

class Jit
{
public:
    Jit(up<llvm::orc::ExecutionSession> inExecutionSession,
        llvm::orc::JITTargetMachineBuilder inJitTargetMachineBuilder,
        llvm::DataLayout inDataLayout)
        : mExecutionSession(mv(inExecutionSession))
        , mDataLayout(mv(inDataLayout))
        , mMangleAndInterner(*this->mExecutionSession, this->mDataLayout)
        , mObjectLinkingLayer(*this->mExecutionSession,
                              /*
 * This is a simple memory manager which implements the methods called by the RuntimeDyId class to allocate
 * memory for section-based loading of objects, usually those generated by the MCJIT execution engine. (Tei Execution 
 * Engine nai ho)
 * 
*/
                              []() { return mu<llvm::SectionMemoryManager>(); })
        , mCompilerLayer(*this->mExecutionSession,
                         mObjectLinkingLayer,
                         /*
                          * Creates a new target machine and simple compiler instance for each
                          * */
                         mu<llvm::orc::ConcurrentIRCompiler>(mv(inJitTargetMachineBuilder)))
        , mMainJittedDynamicLibrary(this->mExecutionSession->createBareJITDylib("<main>"))
    {
        mMainJittedDynamicLibrary.addGenerator(
            llvm::cantFail(llvm::orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(
                mDataLayout.getGlobalPrefix())));

        /*
 * Helper class for working with autoconf configuration names
 * THEY CONTAIN EXACTLY THREE FIELDS   
 * ARCHITECTURE_VENDOR_OPERATINGSYSTEM , like aarch64
 * 
 * COFF = Common Object File Format (Format for executable, and Object Code)
 */
        if (inJitTargetMachineBuilder.getTargetTriple()
                .isOSBinFormatCOFF()) { // IDK what happens to moved thing here
            /*
             *  Workaround to support symbol visibility to CFF 
             */
            mObjectLinkingLayer.setOverrideObjectFlagsWithResponsibilityFlags(true);

            /*
             *	Runtime Dynamic Load  Object linking layer instance will claim responsibility
             *	for any symbols provided by a given object file that were not alreading in
             *	MaterializationResponsibility instance. (IDK what it is)
             */
            mObjectLinkingLayer.setAutoClaimResponsibilityForObjectSymbols(true);
        }
    }

    ~Jit()
    {
        if (auto Error = mExecutionSession->endSession()) {
            mExecutionSession->reportError(mv(Error));
        }
    }

    /* 
     * llvm::Expected chae optional jastai ho, holds either sth or error
     * */
    static llvm::Expected<up<Jit>> Create()
    {
        auto ExecutorProcessControl = llvm::orc::SelfExecutorProcessControl::Create();
        if (not ExecutorProcessControl) {
            return ExecutorProcessControl.takeError();
        }
        up<llvm::orc::ExecutionSession> ExecutionSession = mu<llvm::orc::ExecutionSession>(
            mv(*ExecutorProcessControl));

        llvm::orc::JITTargetMachineBuilder Jtmbuilder(ExecutionSession->getTargetTriple());

        auto DataLayout = Jtmbuilder.getDefaultDataLayoutForTarget();
        if (not DataLayout) {
            return DataLayout.takeError();
        }

        return mu<Jit>(mv(ExecutionSession), mv(Jtmbuilder), mv(*DataLayout));
    }

    const llvm::DataLayout &GetDataLayout() const { return mDataLayout; }
    llvm::orc::JITDylib &GetMainJitDyLib() const { return mMainJittedDynamicLibrary; }

    /*
     * Modules are the top level container that contain all the llvm intermediate representation
     * objects.
     * */
    llvm::Error AddModule(llvm::orc::ThreadSafeModule inTsm,
                          /* Shared pointer of resource tracker, an api to transfer or
                           * remove ownership of JIT resources.
						 */
                          llvm::orc::ResourceTrackerSP inResTracker = nullptr)
    {
        if (not inResTracker) {
            inResTracker = mMainJittedDynamicLibrary.getDefaultResourceTracker();
        }
        return mCompilerLayer.add(mMainJittedDynamicLibrary, mv(inTsm));
    }

    /*
     * Elle chae location of JIT symbol symbol definition store garxa
     * */
    llvm::Expected<llvm::orc::ExecutorSymbolDef> LookUp(llvm::StringRef inName)
    {
        /// Convenience version of blocking lookup.
        /// Searches each of the JITDylibs in the search order in turn for the given
        /// symbol.
        return mExecutionSession->lookup({&mMainJittedDynamicLibrary},
                                         /*
                                          * Functor
                                          * */
                                         mMangleAndInterner(inName.str()));
    }

private:
    // ORC vaneko on request compilation
    up<llvm::orc::ExecutionSession> mExecutionSession;

    /* This is a parsed version of target data layout string in and methods for quering it.*/
    llvm::DataLayout mDataLayout;

    /*
    Symbol Mangling - transforming  a symbol name into a format that incorporates additional infos
    such as namespaces, function signatures etc. << TO uniquely identify the symbol >>

    Symbol Interning - Process of storing a symbol name in a table (intern table) and returning unique
    references to the table. JIT ma useful hunxa jahan eutai kura ko ek vanda badhi references huna sakxa
    */
    llvm::orc::MangleAndInterner mMangleAndInterner;

    /* 
    Handles dynamic linking of Obj files during JIT compilation 
    Runtime Dynamic Loading = LLVM ko runtime dynamic loading facility use garxa in IR, runtime ma.
    Object Linking Layer = Manages linking of Object files, resolving symbols and facilitating the execution of 
    JIT compiled code
    */
    llvm::orc::RTDyldObjectLinkingLayer mObjectLinkingLayer;
    
    /* This layer is responsible to generate machine code from IR on the fly */

    llvm::orc::IRCompileLayer mCompilerLayer;

    /* This represents a JITTed dynamic library */
    llvm::orc::JITDylib &mMainJittedDynamicLibrary;
};
